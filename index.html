<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Watch Together â€” 50/50 + Fit/Fill + L/R Chat Bubbles (+ /yt)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <style>
    :root{
      --bg:#0c0d0f; --panel:#14171b; --border:#232834;
      --text:#e8eef3; --muted:#97a3ae; --accent:#00e1ff;
      --me:#00d4b3; --peer:#ff72d2;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-right: env(safe-area-inset-right, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);

      /* Virtual keyboard support */
      --kbd: 0px;            /* current virtual keyboard height */
      --composer-h: 56px;    /* updated by JS after mount */
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--text);
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      line-height:1.4; overflow:hidden; /* no page scroll */
      padding:var(--safe-top) var(--safe-right) var(--safe-bottom) var(--safe-left);
      /* avoid browser overscroll shifting the layout */
      overscroll-behavior:contain;
    }
    .hidden{display:none !important}

    /* Buttons/Inputs (compact) */
    .btn{
      display:inline-flex; align-items:center; justify-content:center;
      padding:10px 12px; border-radius:10px; border:1px solid var(--border);
      background:#0f1116; color:var(--text); font-weight:600; font-size:14px;
      cursor:pointer; line-height:1; white-space:nowrap;
    }
    .btn-primary{background:var(--accent); color:#001218; border-color:transparent}
    .btn-sm{padding:10px 12px; min-width:96px}
    input[type=text]{
      width:100%; padding:10px 12px; border-radius:10px; border:1px solid var(--border);
      background:#0f1116; color:#e8eef3; font-size:14px; line-height:1;
    }
    input::placeholder{color:var(--muted)}

    /* CONNECT (use 100dvh so mobile shows full UI) */
    .connectScreen{ height:100dvh; width:100vw; display:flex; align-items:center; justify-content:center; padding:16px; }
    .connect{
      width:min(480px, 92vw);
      background:var(--panel); border:1px solid var(--border); border-radius:14px;
      padding:16px; display:flex; flex-direction:column; gap:10px;
    }
    .title{font-weight:800; color:var(--accent); text-align:center}
    .sub{color:var(--muted); font-size:13px; text-align:center}
    .row{display:flex; gap:8px; align-items:center}
    .row input{flex:1}

    /* SESSION: fullscreen split (100dvh for mobile browser chrome) */
    .session{
      height:100dvh; width:100vw; display:grid; gap:0;
      grid-template-columns: 1fr 1fr; grid-template-rows: 1fr; /* desktop: side-by-side */
      position:fixed; inset:0; /* keep layout fixed so video doesn't shift when keyboard opens */
    }
    @media (max-width: 680px){ .session{ grid-template-columns:1fr; grid-template-rows: 1fr 1fr; } }
    .left,.right{min-width:0; min-height:0}

    /* VIDEO (fills its half completely) */
    .left{position:relative; background:#000}
    .videoWrap{position:absolute; inset:0; background:#000; overflow:hidden}
    video{position:absolute; inset:0; width:100%; height:100%; background:#000}
    /* Fit/Fill modes toggled on .left */
    .left.mode-fill video { object-fit:cover; }   /* no gaps, can crop */
    .left.mode-fit  video { object-fit:contain; } /* no crop, may show bars */

    /* YouTube layer */
    #ytWrap{position:absolute; inset:0; display:none; background:#000}
    #ytPlayer{position:absolute; inset:0; width:100%; height:100%; border:0}

    /* badges + fit/fill toggle */
    .badges{
      position:absolute; top:8px; left:8px; display:flex; gap:6px; z-index:2;
      user-select:none; pointer-events:none;
    }
    .badge{
      background:rgba(0,0,0,.45); color:#eaf2f7; border:1px solid rgba(255,255,255,.12);
      padding:4px 8px; border-radius:999px; font-size:12px; backdrop-filter:saturate(120%) blur(6px);
    }
    .chip{
      pointer-events:auto; user-select:none; cursor:pointer;
      padding:4px 8px; border-radius:999px; font-size:12px; font-weight:700;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.55); color:#eaf2f7;
    }

    /* CHAT (right): vertical scroll only + left/right bubbles */
    .right{display:flex; flex-direction:column; background:var(--panel)}
    .chat{flex:1; display:flex; flex-direction:column; min-height:0; border-left:1px solid var(--border); position:relative}

    #messages{
      position:absolute; top:0; left:0; right:0;
      bottom: calc(var(--composer-h) + var(--kbd));
      overflow-y:auto; overflow-x:hidden; padding:12px; background:#0f1116;
      display:flex; flex-direction:column; gap:8px;
      word-break:break-word; overflow-wrap:anywhere; white-space:pre-wrap;
    }
    .line{display:flex; width:100%}
    .from-me{justify-content:flex-end}
    .from-peer{justify-content:flex-start}
    .from-sys{justify-content:center}

    .bubble{ max-width:88%; padding:10px 12px; border-radius:14px; border:1px solid transparent; box-shadow:0 1px 2px rgba(0,0,0,.25); font-size:14px; }
    .bubble.me{ background:rgba(0,212,179,.15); border-color:rgba(0,212,179,.35); color:#d9fff7; border-top-right-radius:6px; }
    .bubble.peer{ background:rgba(255,114,210,.14); border-color:rgba(255,114,210,.35); color:#ffe6f6; border-top-left-radius:6px; }
    .bubble.sys{ background:transparent; border-color:transparent; color:var(--muted); font-size:12px; padding:6px 8px; box-shadow:none; }

    .composer{ position:absolute; left:0; right:0; bottom: var(--kbd); display:flex; gap:8px; padding:8px; border-top:1px solid var(--border); background:var(--panel) }
    .composer input{flex:1}
    .composer button{ padding:10px 12px; border-radius:10px; border:1px solid transparent; background:var(--accent); color:#001218; font-weight:700; }

    .kbd-open #messages{ scroll-behavior:auto; }

    /* Toasts */
    .toasts{position:absolute; top:10px; right:10px; display:flex; flex-direction:column; gap:8px; z-index:5; width:min(360px, 90vw)}
    .toast{display:flex; gap:10px; align-items:flex-start; padding:10px 12px; border-radius:12px; border:1px solid var(--border); backdrop-filter:saturate(120%) blur(6px); box-shadow:0 2px 8px rgba(0,0,0,.35); background:rgba(0,0,0,.6); color:var(--text)}
    .toast .title{font-weight:800; color:inherit; text-align:left}
    .toast .msg{font-size:13px; color:var(--muted)}
    .toast button{margin-left:auto; border:none; background:transparent; color:inherit; cursor:pointer; font-weight:800}
    .toast.error{border-color:#ff6b6b; background:rgba(255,40,40,.12)}
    .toast.warn{border-color:#ffd166; background:rgba(255,209,102,.12)}
    .toast.info{border-color:#4da3ff; background:rgba(77,163,255,.12)}
    .bubble.err{background:rgba(255,40,40,.08); border-color:rgba(255,40,40,.4); color:#ffdfe0; box-shadow:0 2px 6px rgba(255,40,40,.12)}
  </style>
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
</head>
<body>

  <div id="toasts" class="toasts" aria-live="polite"></div>

  <section id="connectScreen" class="connectScreen">
    <div class="connect">
      <div class="title">ðŸŽ¬ Watch Together</div>
      <div class="sub">Desktop: Left video / Right chat (50/50). Mobile: Top/Bottom (50/50).</div>

      <button id="createBtn" class="btn btn-primary">Create Room (Host)</button>

      <div class="row">
        <input id="roomId" type="text" placeholder="Room ID" autofocus />
        <button id="joinBtn" class="btn btn-primary btn-sm">Join</button>
      </div>

      <div id="connectLog" class="sub"></div>
      <div id="connectErr" class="sub" style="color:#ffb4b4"></div>
    </div>
  </section>

  <section id="sessionScreen" class="session hidden">
    <div class="left mode-fill" id="leftPane">
      <div class="videoWrap">
        <div class="badges">
          <span id="roleBadge" class="badge">Not connected</span>
          <span id="statusBadge" class="badge">Idle</span>
          <button id="fitToggle" class="chip" title="Toggle Fit/Fill">Fill</button>
        </div>
        <video id="player" playsinline crossorigin="anonymous"></video>
        <div id="ytWrap"><div id="ytPlayer"></div></div>
      </div>
    </div>

    <div class="right">
      <div class="chat">
        <div id="messages"></div>
        <div class="composer">
          <input id="msgInput" type="text" placeholder="Messageâ€¦ (Host: /load, /yt, /vib)" />
          <button id="sendBtn" class="btn btn-primary btn-sm">Send</button>
        </div>
      </div>
    </div>
  </section>

<script>
  // ===== Shortcuts =====
  const $ = id => document.getElementById(id);
  const connectScreen = $('connectScreen');
  const sessionScreen = $('sessionScreen');
  const roleBadge = $('roleBadge');
  const statusBadge = $('statusBadge');
  const player = $('player');
  const messages = $('messages');
  const leftPane = $('leftPane');
  const fitToggle = $('fitToggle');
  const ytWrap = $('ytWrap');
  const toasts = $('toasts');
  const connectErr = $('connectErr');

  let peer, conn, isHost = false;
  let hls = null;
  let videoLoaded = false;
  let fitMode = null;

  // YouTube state
  let ytPlayer = null;
  let ytActive = false;
  let ytAPIReady = false;
  let ytSyncTimer = null;

  // ==== PeerJS config helper (server + ICE) ====
  function getPeerOptions(){
    // Optional: allow URL params to override server, e.g. ?peer_host=your.host&peer_port=443&peer_path=/peerjs
    const u = new URL(location.href);
    const host = u.searchParams.get('peer_host');
    const port = u.searchParams.get('peer_port');
    const path = u.searchParams.get('peer_path');
    const secure = u.searchParams.get('peer_secure');
    const opts = {};
    if (host || port || path || secure){
      opts.host = host || location.hostname;
      if (port) opts.port = Number(port);
      if (path) opts.path = path;
      if (secure!=null) opts.secure = secure === '1' || secure === 'true';
    }
    // Add basic STUN (you may swap for your TURN here)
    opts.config = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
        // For strict NATs you need a TURN server here.
      ]
    };
    return opts;
  }

  // ===== Fit/Fill Toggle =====
  function setFitMode(mode){
    fitMode = mode;
    leftPane.classList.toggle('mode-fit',  mode==='fit');
    leftPane.classList.toggle('mode-fill', mode==='fill');
    fitToggle.textContent = mode === 'fit' ? 'Fit' : 'Fill';
    fitToggle.title = mode === 'fit' ? 'No crop (bars may appear)' : 'Fill (may crop)';
  }
  function pickDefaultMode(){
    const mobile = window.matchMedia('(max-width: 680px)').matches;
    setFitMode(mobile ? 'fit' : 'fill');
  }
  fitToggle.addEventListener('click', ()=> setFitMode(fitMode === 'fit' ? 'fill' : 'fit'));
  window.addEventListener('resize', ()=>{ if (fitMode==null) pickDefaultMode(); });

  // ===== UI helpers =====
  function showConnect(msg){ $('connectLog').textContent = msg || ''; }
  function dbg(msg){
    const el = $('connectLog');
    el.textContent = (el.textContent ? el.textContent + "\n" : "") + msg;
  }
  function toSession(role){
    connectScreen.classList.add('hidden');
    sessionScreen.classList.remove('hidden');
    sessionScreen.classList.toggle('role-host', role==='host');
    sessionScreen.classList.toggle('role-guest', role!=='host');
    roleBadge.textContent = role==='host' ? 'Host' : 'Guest';
    if (role==='host') player.setAttribute('controls',''); else player.removeAttribute('controls');
    if (fitMode==null) pickDefaultMode();
  }

  function addBubble(text, who){
    const line = document.createElement('div');
    line.className = 'line ' + (who==='me' ? 'from-me' : who==='peer' ? 'from-peer' : 'from-sys');
    const b = document.createElement('div');
    b.className = 'bubble ' + (who==='me' ? 'me' : who==='peer' ? 'peer' : 'sys');
    b.innerHTML = text;
    line.appendChild(b);
    messages.appendChild(line);
    messages.scrollTop = messages.scrollHeight;
  }
  function log(html, cls){
    if (cls === 'sys') return; // silent system messages
    if (cls === 'err') { addBubble(html, 'sys'); return; }
    addBubble(html, cls==='me' ? 'me' : 'peer');
  }
  function setStatus(text){ statusBadge.textContent = text; }
  function escapeHtml(s){ return s.replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;' }[m])) }

  // Toasts
  function pushToast(type, title, msg){
    const t = document.createElement('div'); t.className = `toast ${type}`;
    t.innerHTML = `<div class="title">${escapeHtml(title)}</div><div class="msg">${escapeHtml(msg||'')}</div>`;
    const close = document.createElement('button'); close.setAttribute('aria-label','Dismiss'); close.textContent='âœ•';
    close.onclick = ()=> t.remove();
    t.appendChild(close);
    toasts.appendChild(t);
    setTimeout(()=>{ t.remove(); }, 6000);
  }
  function showError(title, msg){ pushToast('error', title, msg||''); log(`<b>${escapeHtml(title)}:</b> ${escapeHtml(msg||'')}`, 'err'); }
  function showInfo(title, msg){ pushToast('info', title, msg||''); }

  // ===== Connect flow =====
  $('createBtn').onclick = () => {
    if (!navigator.onLine){ showError('You are offline','Connect to the internet and try again.'); return; }
    if (!window.Peer){ showError('PeerJS missing','The PeerJS script failed to load.'); return; }
    try{
      connectErr.textContent = '';
      showConnect('Creating roomâ€¦');
      isHost = true;
      peer = new Peer(getPeerOptions()); // You can also pass custom PeerServer config here

      const watchdog = setTimeout(()=>{
        showError('Peer server unreachable','Could not establish a connection to the Peer server.');
        connectErr.textContent = 'Peer server unreachable. Check network or try again.';
      }, 8000);

      peer.on('open', id => {
        clearTimeout(watchdog);
        showConnect(`Room ID: ${id}`);
        dbg('Peer open âœ“');
      });
      peer.on('connection', c => { conn = c; wireConnection(); toSession('host'); });
      peer.on('error', err => { showError('Peer error', err?.message || String(err)); connectErr.textContent = err?.message || String(err); });
      peer.on('disconnected', ()=> showError('Disconnected', 'The peer server connection dropped.'));
    }catch(e){ showError('Create room failed', e?.message || String(e)); }
  };

  $('joinBtn').onclick = tryJoin;
  $('roomId').addEventListener('keydown', e => { if (e.key === 'Enter') tryJoin(); });

  function tryJoin(){
    const id = $('roomId').value.trim();
    if (!id) { showConnect('Enter a room ID.'); connectErr.textContent = 'Room ID is required to join.'; $('roomId').focus(); showError('Missing Room ID','Please enter a Room ID and try again.'); return; }
    if (!navigator.onLine){ showError('You are offline','Connect to the internet and try again.'); return; }
    if (!window.Peer){ showError('PeerJS missing','The PeerJS script failed to load.'); return; }
    isHost = false;
    try{
      connectErr.textContent = '';
      showConnect('Joining roomâ€¦');
      peer = new Peer(getPeerOptions());

      const watchdog = setTimeout(()=>{
        showError('Peer server unreachable','Could not connect to the Peer server.');
        connectErr.textContent = 'Peer server unreachable. Check network or try again.';
      }, 8000);

      peer.on('open', () => {
        clearTimeout(watchdog);
        conn = peer.connect(id);
        // Watchdog for stuck joining
        const joinWatch = setTimeout(()=>{
          if (!conn.open){
            showError('Could not join', 'Timed out opening a data connection. Possible causes: wrong Room ID, host closed the page, or network blocks WebSocket/WebRTC.');
          }
        }, 10000);
        conn.on('open', () => { clearTimeout(joinWatch); wireConnection(); toSession('guest'); });
        conn.on('error', err => { showError('Connection error', err?.message || String(err)); });
        conn.on('close', () => { showError('Connection closed','Peer disconnected. Reloadingâ€¦'); setTimeout(()=>location.reload(), 1200); });
      });
        conn.on('error', err => { showError('Connection error', err?.message || String(err)); });
        conn.on('close', () => { showError('Connection closed','Peer disconnected. Reloadingâ€¦'); setTimeout(()=>location.reload(), 1200); });
      });
      peer.on('error', err => { clearTimeout(watchdog); showError('Peer error', err?.message || String(err)); connectErr.textContent = err?.message || String(err); });
    }catch(e){ showError('Join failed', e?.message || String(e)); }
  }

  // ===== Vibration API =====
  function applyVibration(pattern) {
    if (typeof navigator.vibrate === 'function') {
      try{ navigator.vibrate(pattern); }catch(e){ showError('Vibration failed', e?.message || String(e)); }
    } else {
      showError('Vibration unsupported','This device/browser does not support the Vibration API.');
    }
  }

  // ===== wireConnection (chat + commands) =====
  function wireConnection(){
    conn.on('data', data => {
      try{
        if (data.type === 'chat'){
          log(`<b>Peer:</b> ${escapeHtml(data.text)}`, 'peer');
        } else if (data.type === 'cmd' && data.cmd === 'load'){
          loadMedia(data.url, false);
        } else if (data.type === 'cmd' && data.cmd === 'yt'){
          loadYouTubeById(data.videoId, false);
        } else if (data.type === 'sync'){
          applySync(data);
        } else if (data.type === 'vibrate'){
          applyVibration(data.pattern);
        }
      }catch(e){ showError('Incoming data error', e?.message || String(e)); }
    });
    conn.on('close', () => {
      showError('Connection closed','Peer connection was closed. Reloadingâ€¦');
      setTimeout(()=> location.reload(), 1200);
    });
    conn.on('error', err => showError('Connection error', err?.message || String(err)));
  }

  // ===== Chat (commands: /load, /yt, /vib) =====
  $('sendBtn').onclick = sendMsg;
  $('msgInput').addEventListener('keydown', e => { if (e.key === 'Enter') sendMsg(); });

  const secToMs = (val) => Math.round(parseFloat(val) * 1000);

  function sendMsg(){
    const el = $('msgInput'), text = el.value.trim();
    if (!text) return;
    if (!conn || (conn.open===false)) { showError('Not connected','Create or join a room before sending messages.'); return; }

    // Host-only commands
    if (isHost) {
      if (text.startsWith('/load ')) {
        const url = text.slice(6).trim();
        if (!url){ showError('Missing URL','/load requires a media URL.'); el.value=''; return; }
        try{ loadMedia(url, true); }catch(e){ showError('Load failed', e?.message || String(e)); }
        el.value = ''; return;
      } else if (text.startsWith('/yt ')) {
        const url = text.slice(4).trim();
        const vid = extractYouTubeId(url);
        if (!vid) { showError('Invalid YouTube URL','Could not extract a video ID.'); el.value=''; return; }
        loadYouTubeById(vid, true).catch(e=> showError('YouTube load failed', e?.message || String(e)));
        el.value = ''; return;
      } else if (text.startsWith('/vib ')) {
        const payload = text.slice(5).trim();
        if (!payload) { showError('Vibration payload missing','Provide seconds or a comma pattern.'); el.value = ''; return; }
        let pattern;
        if (payload.includes(',')) { pattern = payload.split(',').map(sec => secToMs(sec)); }
        else { pattern = secToMs(payload); }
        if ((Array.isArray(pattern) && pattern.some(x=>Number.isNaN(x))) || (!Array.isArray(pattern) && Number.isNaN(pattern))) {
          showError('Invalid vibration pattern','Use numbers in seconds, e.g., "/vib 0.1,0.1,0.2"'); el.value = ''; return;
        }
        try{ applyVibration(pattern); conn?.send({type:'vibrate', pattern}); }catch(e){ showError('Vibration failed', e?.message || String(e)); }
        el.value = ''; return;
      }
    }

    // Regular chat
    try{
      log(`<b>You:</b> ${escapeHtml(text)}`, 'me');
      conn?.send({type:'chat', text});
    }catch(e){ showError('Send failed', e?.message || String(e)); }
    el.value = '';
  }

  // ===== Media loading (HTML5 + HLS) =====
  function cleanup(){
    // stop YT if active
    if (ytActive) destroyYouTube();
    if (hls){ try{ hls.destroy(); }catch(e){} hls = null; }
    player.pause(); player.removeAttribute('src'); player.load();
    videoLoaded = false;
  }

  function loadMedia(url, broadcast){
    cleanup();
    setStatus('Loadingâ€¦');

    if (url.toLowerCase().includes('.m3u8')){
      if (window.Hls && Hls.isSupported()){
        try{
          hls = new Hls({ backBufferLength: 600, liveSyncDuration: 6, liveMaxLatencyDuration: 300 });
          hls.on(Hls.Events.ERROR, (_, data)=> { console.warn('hls.js error', data); showError('HLS error', (data && (data.details||data.type)) || 'Unknown HLS error'); });
          hls.loadSource(url);
          hls.attachMedia(player);
          hls.on(Hls.Events.MANIFEST_PARSED, ()=>{ videoLoaded = true; setStatus('Ready'); if (!isHost) player.currentTime = 0; });
        }catch(e){ showError('HLS setup failed', e?.message || String(e)); return; }
      } else if (player.canPlayType('application/vnd.apple.mpegurl')){
        player.src = url; player.onloadedmetadata = ()=>{ videoLoaded = true; setStatus('Ready'); };
      } else {
        setStatus('HLS unsupported in this browser');
        showError('HLS unsupported','This browser cannot play HLS (.m3u8) streams.');
        return;
      }
    } else {
      player.src = url;
      player.onloadedmetadata = ()=>{ videoLoaded = true; setStatus('Ready'); };
    }

    player.onerror = () => {
      const err = player.error; const msg = err ? (err.message || `Media error code ${err.code}`) : 'Unknown video error';
      showError('Video playback error', msg);
    };

    if (broadcast){ try{ conn?.send({type:'cmd', cmd:'load', url}); }catch(e){ showError('Broadcast failed', e?.message || String(e)); } }
  }

  // ===== Sync host -> guest =====
  player.addEventListener('play', () => {
    if (!isHost || !videoLoaded || ytActive) return;
    conn?.send({type:'sync', action:'play', time:player.currentTime, media:'html5'});
  });
  player.addEventListener('pause', () => {
    if (!isHost || !videoLoaded || ytActive) return;
    conn?.send({type:'sync', action:'pause', time:player.currentTime, media:'html5'});
  });
  let seekTimer;
  player.addEventListener('seeked', () => {
    if (!isHost || !videoLoaded || ytActive) return;
    clearTimeout(seekTimer);
    seekTimer = setTimeout(()=> {
      conn?.send({type:'sync', action:'seek', time:player.currentTime, media:'html5'});
    }, 80);
  });

  function applySync(msg){
    // Route based on active media
    if (ytActive && ytPlayer){
      const t = msg.time ?? 0;
      const getT = ytPlayer.getCurrentTime ? ytPlayer.getCurrentTime() : 0;
      const diff = Math.abs(getT - t);
      if (msg.action === 'play') {
        if (diff > 0.4) ytPlayer.seekTo(t, true);
        ytPlayer.playVideo && ytPlayer.playVideo();
      } else if (msg.action === 'pause') {
        if (diff > 0.4) ytPlayer.seekTo(t, true);
        ytPlayer.pauseVideo && ytPlayer.pauseVideo();
      } else if (msg.action === 'seek' || msg.action === 'time') {
        if (diff > 0.4) ytPlayer.seekTo(t, true);
      }
      return;
    }
    // HTML5 video path
    if (!videoLoaded) return;
    const diff = Math.abs(player.currentTime - msg.time);
    if (diff > 0.4) player.currentTime = msg.time;
    if (msg.action === 'play')  player.play().catch(()=>{});
    if (msg.action === 'pause') player.pause();
  }

  // ===== Keyboard-aware chat =====
  (function setupKeyboardAwareChat(){
    const vv = window.visualViewport;
    const composer = document.querySelector('.composer');
    function setVar(name, val){ document.documentElement.style.setProperty(name, val); }
    function measureComposer(){ if (composer) setVar('--composer-h', composer.offsetHeight + 'px'); }
    function updateKeyboardOffset(){
      const kb = vv ? Math.max(0, (window.innerHeight - vv.height - vv.offsetTop)) : 0;
      const isOpen = kb > 120;
      setVar('--kbd', (isOpen ? kb : 0) + 'px');
      document.body.classList.toggle('kbd-open', isOpen);
      measureComposer();
    }
    window.addEventListener('load', updateKeyboardOffset, { once:true });
    window.addEventListener('resize', updateKeyboardOffset);
    window.addEventListener('orientationchange', updateKeyboardOffset);
    if (vv){ vv.addEventListener('resize', updateKeyboardOffset); vv.addEventListener('scroll', updateKeyboardOffset); }
    const msgInput = document.getElementById('msgInput');
    if (msgInput){ msgInput.addEventListener('focus', () => { setTimeout(updateKeyboardOffset, 0); }); msgInput.addEventListener('blur',  () => { setTimeout(updateKeyboardOffset, 0); }); }
  })();

  // ===== YouTube helpers (/yt) =====
  function injectYouTubeAPI(){
    return new Promise((resolve, reject) => {
      if (ytAPIReady) return resolve();
      if (window.YT && window.YT.Player){ ytAPIReady = true; return resolve(); }
      const tag = document.createElement('script');
      tag.src = 'https://www.youtube.com/iframe_api';
      tag.onerror = () => { showError('YouTube API load failed','Check your network connection.'); reject(new Error('YT API load failed')); };
      document.head.appendChild(tag);
      window.onYouTubeIframeAPIReady = () => { ytAPIReady = true; resolve(); };
    });
  }

  function extractYouTubeId(url){
    try{
      const u = new URL(url);
      if (u.hostname.includes('youtu.be')) return u.pathname.slice(1);
      if (u.searchParams.get('v')) return u.searchParams.get('v');
      const path = u.pathname.split('/').filter(Boolean);
      const idx = path.indexOf('shorts'); if (idx !== -1 && path[idx+1]) return path[idx+1];
      const eidx = path.indexOf('embed'); if (eidx !== -1 && path[eidx+1]) return path[eidx+1];
      return null;
    }catch(e){ return null; }
  }

  async function loadYouTubeById(videoId, broadcast){
    cleanup();
    setStatus('Loadingâ€¦');
    await injectYouTubeAPI();
    ytWrap.style.display = 'block';
    player.style.display = 'none';
    ytActive = true;
    ytPlayer = new YT.Player('ytPlayer', {
      videoId,
      playerVars: { rel:0, modestbranding:1, playsinline:1, fs:1, controls: isHost ? 1 : 0, disablekb: isHost ? 0 : 1 },
      events: {
        onReady: () => { videoLoaded = true; setStatus('Ready'); },
        onStateChange: (ev) => {
          if (!isHost || !videoLoaded) return;
          const t = ytPlayer.getCurrentTime ? ytPlayer.getCurrentTime() : 0;
          if (ev.data === YT.PlayerState.PLAYING){ conn?.send({type:'sync', action:'play', time:t, media:'yt'}); startYTSyncTicker(); }
          else if (ev.data === YT.PlayerState.PAUSED){ conn?.send({type:'sync', action:'pause', time:t, media:'yt'}); stopYTSyncTicker(); }
          else if (ev.data === YT.PlayerState.BUFFERING){ conn?.send({type:'sync', action:'seek', time:t, media:'yt'}); }
          else if (ev.data === YT.PlayerState.ENDED){ stopYTSyncTicker(); }
        },
        onError: (ev) => {
          const codes = {2:'Invalid parameter',5:'HTML5 playback issue',100:'Video not found/private',101:'Embedding disabled',150:'Embedding disabled'};
          showError('YouTube error', codes[ev?.data] || `Player error code ${ev?.data}`);
        }
      }
    });
    if (broadcast){ try{ conn?.send({type:'cmd', cmd:'yt', videoId}); }catch(e){ showError('Broadcast failed', e?.message || String(e)); } }
  }

  function destroyYouTube(){
    stopYTSyncTicker();
    try{ ytPlayer && ytPlayer.destroy && ytPlayer.destroy(); }catch(e){}
    ytPlayer = null; ytActive = false; ytWrap.style.display = 'none'; player.style.display = 'block';
  }
  function startYTSyncTicker(){ stopYTSyncTicker(); ytSyncTimer = setInterval(()=>{ if (!isHost || !ytPlayer) return; const t = ytPlayer.getCurrentTime ? ytPlayer.getCurrentTime() : 0; conn?.send({type:'sync', action:'time', time:t, media:'yt'}); }, 2000); }
  function stopYTSyncTicker(){ if (ytSyncTimer){ clearInterval(ytSyncTimer); ytSyncTimer = null; } }

  // Init default fit/fill on load
  window.addEventListener('load', pickDefaultMode);

  // Global error catches
  window.addEventListener('error', (e) => { showError('Script error', e?.message || 'Unknown script error'); });
  window.addEventListener('unhandledrejection', (e) => { const msg = (e && e.reason && (e.reason.message || String(e.reason))) || 'Unhandled promise rejection'; showError('Unhandled error', msg); });

  // Detect missing PeerJS after load (CDN blocked?)
  window.addEventListener('load', () => { setTimeout(() => { if (!window.Peer){ showError('PeerJS not loaded','The PeerJS CDN may be blocked. Try a different network or allow the script.'); } }, 1500); });

  // Show online/offline state
  window.addEventListener('offline', () => showError('You went offline','Reconnect to continue.'));
  window.addEventListener('online', () => showInfo('Back online','You can create or join rooms again.'));
</script>
</body>
</html>
