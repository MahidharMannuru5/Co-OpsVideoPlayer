<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Watch Together â€” 50/50 + Fit/Fill + L/R Chat Bubbles</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <style>
        :root{
            --bg:#0c0d0f; --panel:#14171b; --border:#232834;
            --text:#e8eef3; --muted:#97a3ae; --accent:#00e1ff;
            --me:#00d4b3; --peer:#ff72d2;
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-right: env(safe-area-inset-right, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --safe-left: env(safe-area-inset-left, 0px);

            --kbd: 0px;
            --composer-h: 56px;
        }
        *{box-sizing:border-box}
        html,body{height:100%}
        body{
            margin:0; background:var(--bg); color:var(--text);
            font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
            line-height:1.4; overflow:hidden;
            padding:var(--safe-top) var(--safe-right) var(--safe-bottom) var(--safe-left);
            overscroll-behavior:contain;
        }
        .hidden{display:none !important}

        .btn{
            display:inline-flex; align-items:center; justify-content:center;
            padding:10px 12px; border-radius:10px; border:1px solid var(--border);
            background:#0f1116; color:var(--text); font-weight:600; font-size:14px;
            cursor:pointer; line-height:1; white-space:nowrap;
        }
        .btn-primary{background:var(--accent); color:#001218; border-color:transparent}
        .btn-sm{padding:10px 12px; min-width:96px}
        input[type=text]{
            width:100%; padding:10px 12px; border-radius:10px; border:1px solid var(--border);
            background:#0f1116; color:#e8eef3; font-size:14px; line-height:1;
        }
        input::placeholder{color:var(--muted)}

        .connectScreen{
            height:100dvh; width:100vw; display:flex; align-items:center; justify-content:center; padding:16px;
        }
        .connect{
            width:min(480px, 92vw);
            background:var(--panel); border:1px solid var(--border); border-radius:14px;
            padding:16px; display:flex; flex-direction:column; gap:10px;
        }
        .title{font-weight:800; color:var(--accent); text-align:center}
        .sub{color:var(--muted); font-size:13px; text-align:center}
        .row{display:flex; gap:8px; align-items:center}
        .row input{flex:1}

        .session{
            height:100dvh; width:100vw; display:grid; gap:0;
            grid-template-columns: 1fr 1fr; grid-template-rows: 1fr;
            position:fixed; inset:0;
        }
        /* SOLO mode: expand video to full width when chat is hidden (e.g., cam-on) */
        .session.solo{ grid-template-columns: 1fr; }

        @media (max-width: 680px){
            .session{ grid-template-columns:1fr; grid-template-rows: 1fr 1fr; }
            .session.solo{ grid-template-rows: 1fr; }
        }

        .left,.right{min-width:0; min-height:0}
        .left{position:relative; background:#000}

        .videoWrap{
            position:absolute; inset:0; background:#000; overflow:hidden;
            /* help some browsers force reflow correctly */
            display:block; width:100%; height:100%;
        }

        /* HTML5/HLS video defaults to fill space; object-fit controlled by mode-fit/mode-fill */
        video#player{position:absolute; inset:0; width:100%; height:100%; background:#000}

        /* Fit/Fill modes */
        .left.mode-fill video#player { object-fit:cover; }
        .left.mode-fit  video#player { object-fit:contain; }

        /* YouTube iframe should also fully cover .videoWrap */
        .ytBox, .ytBox iframe{
            position:absolute; inset:0; width:100%; height:100%;
            display:block; background:#000;
        }

        .role-host video{pointer-events:auto}
        .role-guest video{pointer-events:none}

        .badges{
            position:absolute; top:8px; left:8px; display:flex; gap:6px; z-index:5;
            user-select:none; pointer-events:none;
        }
        .badge{
            background:rgba(0,0,0,.45); color:#eaf2f7; border:1px solid rgba(255,255,255,.12);
            padding:4px 8px; border-radius:999px; font-size:12px; backdrop-filter:saturate(120%) blur(6px);
        }
        .chip{
            pointer-events:auto; user-select:none; cursor:pointer;
            padding:4px 8px; border-radius:999px; font-size:12px; font-weight:700;
            border:1px solid rgba(255,255,255,.18);
            background:rgba(0,0,0,.55); color:#eaf2f7;
        }

        .right{display:flex; flex-direction:column; background:var(--panel)}
        .chat{flex:1; display:flex; flex-direction:column; min-height:0; border-left:1px solid var(--border)}

        #messages{
            flex:1; min-height:0; overflow-y:auto; overflow-x:hidden; padding:12px; background:#0f1116;
            display:flex; flex-direction:column; gap:8px;
            word-break:break-word; overflow-wrap:anywhere; white-space:pre-wrap;
            position:absolute; top:0; left:0; right:0;
            bottom: calc(var(--composer-h) + var(--kbd));
        }
        .line{display:flex; width:100%}
        .from-me{justify-content:flex-end}
        .from-peer{justify-content:flex-start}
        .from-sys{justify-content:center}

        .bubble{
            max-width:88%;
            padding:10px 12px; border-radius:14px;
            border:1px solid transparent; box-shadow:0 1px 2px rgba(0,0,0,.25);
            font-size:14px;
        }
        .bubble.me{
            background:rgba(0,212,179,.15); border-color:rgba(0,212,179,.35); color:#d9fff7;
            border-top-right-radius:6px;
        }
        .bubble.peer{
            background:rgba(255,114,210,.14); border-color:rgba(255,114,210,.35); color:#ffe6f6;
            border-top-left-radius:6px;
        }
        .bubble.sys{
            background:transparent; border-color:transparent; color:var(--muted);
            font-size:12px; padding:6px 8px; box-shadow:none;
        }

        .composer{
            display:flex; gap:8px; padding:8px; border-top:1px solid var(--border); background:var(--panel);
            position:absolute; left:0; right:0; bottom: var(--kbd);
        }
        .composer input{flex:1}
        .composer button{
            padding:10px 12px; border-radius:10px; border:1px solid transparent;
            background:var(--accent); color:#001218; font-weight:700;
        }

        .kbd-open #messages{ scroll-behavior:auto; }

        /* Camera overlay */
        .peerVideoBox{
            position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
            background:#000; z-index:4;
        }
        .peerVideoBox video{
            max-width:100%; max-height:100%; border:2px solid var(--accent); border-radius:12px;
        }
        .selfPip{
            position:absolute; bottom:10px; right:10px; width:200px; z-index:6;
            border:2px solid rgba(255,255,255,.25); border-radius:10px; box-shadow:0 4px 12px rgba(0,0,0,.4);
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script src="https://www.youtube.com/iframe_api"></script>
</head>
<body>

<section id="connectScreen" class="connectScreen">
    <div class="connect">
        <div class="title">ðŸŽ¬ Watch Together</div>
        <div class="sub">Desktop: Left video / Right chat (50/50). Mobile: Top/Bottom (50/50).</div>

        <button id="createBtn" class="btn btn-primary">Create Room (Host)</button>

        <div class="row">
            <input id="roomId" type="text" placeholder="Room ID" autofocus />
            <button id="joinBtn" class="btn btn-primary btn-sm">Join</button>
        </div>

        <div id="connectLog" class="sub"></div>
    </div>
</section>

<section id="sessionScreen" class="session hidden" id="session">
    <div class="left mode-fill" id="leftPane">
        <div class="videoWrap" id="videoWrap">
            <div class="badges">
                <span id="roleBadge" class="badge">Not connected</span>
                <span id="statusBadge" class="badge">Idle</span>
                <button id="fitToggle" class="chip" title="Toggle Fit/Fill">Fill</button>
            </div>
            <video id="player" playsinline crossorigin="anonymous"></video>
            <!-- YouTube container will be mounted dynamically when needed -->
        </div>
    </div>

    <div class="right" id="rightPane">
        <div class="chat">
            <div id="messages"></div>
            <div class="composer">
                <input id="msgInput" type="text" placeholder="Messageâ€¦ (Host: /load, /yt, /vib â€¢ Both: /cam)" />
                <button id="sendBtn" class="btn btn-primary btn-sm">Send</button>
            </div>
        </div>
    </div>
</section>

<script>
    // ===== Shortcuts =====
    const $ = id => document.getElementById(id);
    const connectScreen = $('connectScreen');
    const sessionScreen = $('sessionScreen');
    const roleBadge = $('roleBadge');
    const statusBadge = $('statusBadge');
    const player = $('player');
    const messages = $('messages');
    const leftPane = $('leftPane');
    const rightPane = $('rightPane');
    const fitToggle = $('fitToggle');
    const videoWrap = $('videoWrap');

    // If these are injected by a wrapper (e.g., Streamlit), use them; else default
    const ROOM_ID = (window.__WATCH_TOGETHER__ && window.__WATCH_TOGETHER__.ROOM_ID) || '';
    const ROLE = (window.__WATCH_TOGETHER__ && window.__WATCH_TOGETHER__.ROLE) || '';
    const DEFAULT_VIDEO_URL = (window.__WATCH_TOGETHER__ && window.__WATCH_TOGETHER__.DEFAULT_VIDEO_URL) || '';

    let peer, conn, isHost = false;
    let hls = null;
    let videoLoaded = false;
    let fitMode = null;

    // YouTube + Camera state
    let ytPlayer = null;
    let usingYT = false;
    let camStream = null;
    let camOn = false;
    let remoteVideoEl = null;
    let selfVideoEl = null;

    // ===== Fit/Fill Toggle =====
    function setFitMode(mode){
        fitMode = mode;
        leftPane.classList.toggle('mode-fit',  mode==='fit');
        leftPane.classList.toggle('mode-fill', mode==='fill');
        fitToggle.textContent = mode === 'fit' ? 'Fit' : 'Fill';
        fitToggle.title = mode === 'fit' ? 'No crop (bars may appear)' : 'Fill (may crop)';
    }
    function pickDefaultMode(){
        const mobile = window.matchMedia('(max-width: 680px)').matches;
        setFitMode(mobile ? 'fit' : 'fill');
    }
    fitToggle.addEventListener('click', ()=> setFitMode(fitMode === 'fit' ? 'fill' : 'fit'));
    window.addEventListener('resize', ()=>{ if (fitMode==null) pickDefaultMode(); });

    // ===== UI helpers =====
    function showConnect(msg){ $('connectLog').textContent = msg || ''; }
    function toSession(role){
        connectScreen.classList.add('hidden');
        sessionScreen.classList.remove('hidden');
        sessionScreen.classList.toggle('role-host', role==='host');
        sessionScreen.classList.toggle('role-guest', role!=='host');
        roleBadge.textContent = role==='host' ? 'Host' : 'Guest';
        if (role==='host') player.setAttribute('controls',''); else player.removeAttribute('controls');
        if (fitMode==null) pickDefaultMode();

        // Load default URL (host only) if provided
        if (DEFAULT_VIDEO_URL && role==='host') {
            loadMedia(DEFAULT_VIDEO_URL, true);
        }
    }
    function log(html, cls){
        if (cls === 'sys') { console.log("[SYS]", html.replace(/<[^>]*>?/gm, '')); return; }
        const line = document.createElement('div');
        line.className = 'line ' + (cls==='me' ? 'from-me' : 'from-peer');
        const b = document.createElement('div');
        b.className = 'bubble ' + (cls==='me' ? 'me' : 'peer');
        b.innerHTML = html;
        line.appendChild(b);
        messages.appendChild(line);
        messages.scrollTop = messages.scrollHeight;
    }
    function setStatus(text){ statusBadge.textContent = text; }
    function escapeHtml(s){ return s.replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':m==='"'?'&quot;':'&#39;' }[m])) }

    // ===== Connection flow =====
    $('createBtn').onclick = () => {
        isHost = true;
        peer = new Peer();
        peer.on('open', id => {
            showConnect(`Room ID: ${id}`);
        });
        peer.on('connection', c => {
            conn = c;
            wireConnection();
            toSession('host');
            // Send a snapshot of current state so guest locks instantly
            sendSnapshot();
        });
    };

    $('joinBtn').onclick = tryJoin;
    $('roomId').addEventListener('keydown', e => { if (e.key === 'Enter') tryJoin(); });

    // Auto-trigger if ROLE/ROOM_ID provided by wrapper
    window.addEventListener('load', () => {
        if (ROLE === 'Host') $('createBtn').click();
        else if (ROLE === 'Guest' && ROOM_ID) {
            $('roomId').value = ROOM_ID; $('joinBtn').click();
        }
    });

    function tryJoin(){
        const id = $('roomId').value.trim();
        if (!id) { showConnect('Enter a room ID.'); $('roomId').focus(); return; }
        isHost = false;
        peer = new Peer();
        peer.on('open', () => {
            conn = peer.connect(id);
            conn.on('open', () => {
                wireConnection(); toSession('guest');
            });
        });
    }

    // Vibrate
    function applyVibration(pattern) {
        if (typeof navigator.vibrate === 'function') navigator.vibrate(pattern);
    }

    // ===== Camera (local toggle) =====
    function ensurePeerVideoBox(){
        let box = document.querySelector('.peerVideoBox');
        if (!box){
            box = document.createElement('div');
            box.className = 'peerVideoBox';
            leftPane.appendChild(box);
        }
        return box;
    }
    function showRemoteStream(stream){
        const box = ensurePeerVideoBox();
        if (!remoteVideoEl){
            remoteVideoEl = document.createElement('video');
            remoteVideoEl.autoplay = true; remoteVideoEl.playsInline = true;
            box.innerHTML = ''; box.appendChild(remoteVideoEl);
        }
        remoteVideoEl.srcObject = stream;
    }
    function hidePeerVideo(){
        const box = document.querySelector('.peerVideoBox');
        if (box) box.remove();
        remoteVideoEl = null;
    }
    function mountSelfPreview(stream){
        if (!selfVideoEl){
            selfVideoEl = document.createElement('video');
            selfVideoEl.autoplay = true; selfVideoEl.muted = true; selfVideoEl.playsInline = true;
            selfVideoEl.className = 'selfPip';
            leftPane.appendChild(selfVideoEl);
        }
        selfVideoEl.srcObject = stream;
    }
    function unmountSelfPreview(){
        if (selfVideoEl){ selfVideoEl.srcObject = null; selfVideoEl.remove(); selfVideoEl = null; }
    }
    async function startCam(){
        if (camOn) return;
        try{
            camStream = await navigator.mediaDevices.getUserMedia({ video:true, audio:true });
            camOn = true;
            sessionScreen.classList.add('solo');   // expand video pane when chat is hidden
            rightPane.classList.add('hidden');     // hide chat area
            mountSelfPreview(camStream);

            // call peer with our stream (after data conn is live)
            if (conn && conn.peer){
                const call = peer.call(conn.peer, camStream);
                call.on('stream', s => showRemoteStream(s));
                call.on('close', () => hidePeerVideo());
            }
        }catch(e){
            log(`<i>Camera access denied.</i>`, 'sys');
        }
    }
    function stopCam(){
        if (!camOn) return;
        camStream?.getTracks().forEach(t=>t.stop());
        camStream = null;
        camOn = false;
        sessionScreen.classList.remove('solo');
        rightPane.classList.remove('hidden');
        unmountSelfPreview();
        hidePeerVideo();
    }
    function toggleCam(){ camOn ? stopCam() : startCam(); }

    function wireCalls(){
        peer.on('call', call => {
            call.answer(camStream || undefined);
            call.on('stream', s => showRemoteStream(s));
            call.on('close', () => hidePeerVideo());
        });
    }

    // ===== Peer data wiring (chat/cmd/sync/yt) =====
    function wireConnection(){
        wireCalls();

        conn.on('data', data => {
            if (data.type === 'chat'){
                log(`<b>Peer:</b> ${escapeHtml(data.text)}`, 'peer');
            } else if (data.type === 'cmd'){
                if (data.cmd === 'load') loadMedia(data.url, false);
            } else if (data.type === 'sync'){
                applySync(data);
            } else if (data.type === 'vibrate'){
                applyVibration(data.pattern);
            } else if (data.type === 'yt'){
                handleYT(data);
            } else if (data.type === 'state'){
                // Full snapshot from host (source + mode + time + playing)
                applyStateSnapshot(data.payload);
            }
        });
        conn.on('close', () => location.reload());
    }

    // ===== Chat & Commands =====
    $('sendBtn').onclick = sendMsg;
    $('msgInput').addEventListener('keydown', e => { if (e.key === 'Enter') sendMsg(); });

    const secToMs = (val) => Math.round(parseFloat(val) * 1000);

    function sendMsg(){
        const el = $('msgInput'), text = el.value.trim();
        if (!text) return;

        // HOST commands
        if (isHost) {
            if (text.startsWith('/load ')) {
                const url = text.slice(6).trim();
                if (url) loadMedia(url, true);
                el.value = ''; return;
            } else if (text.startsWith('/vib ')) {
                const payload = text.slice(5).trim();
                if (!payload) { el.value = ''; return; }
                let pattern = payload.includes(',') ? payload.split(',').map(sec => secToMs(sec)) : secToMs(payload);
                if (pattern === 0 || (Array.isArray(pattern) && pattern.some(isNaN))) { el.value=''; return; }
                applyVibration(pattern);
                conn?.send({type:'vibrate', pattern});
                el.value = ''; return;
            } else if (text.startsWith('/yt ')) {
                const url = text.slice(4).trim();
                const vid = extractYT(url);
                if (vid){ loadYouTube(vid, true); }
                el.value = ''; return;
            }
        }

        // BOTH: /cam
        if (text === '/cam'){ toggleCam(); el.value = ''; return; }

        // Regular chat
        log(`<b>You:</b> ${escapeHtml(text)}`, 'me');
        conn?.send({type:'chat', text});
        el.value = '';
    }

    // ===== Media: HTML5/HLS =====
    function cleanup(){
        // Destroy YT if present
        if (ytPlayer && ytPlayer.destroy){ try{ ytPlayer.destroy(); }catch(e){} }
        ytPlayer = null; usingYT = false;

        // Destroy HLS + HTML5
        if (hls){ try{ hls.destroy(); }catch(e){} hls = null; }
        player.pause(); player.removeAttribute('src'); player.load();
        videoLoaded = false;

        // Ensure HTML5 video exists & fills
        if (!videoWrap.querySelector('#player')){
            const v = document.createElement('video');
            v.id = 'player'; v.setAttribute('playsinline',''); v.setAttribute('crossorigin','anonymous');
            v.style.position = 'absolute'; v.style.inset = '0'; v.style.width='100%'; v.style.height='100%';
            videoWrap.appendChild(v);
        }
        // Remove any YT box remnants
        const yt = videoWrap.querySelector('.ytBox'); if (yt) yt.remove();
    }

    function loadMedia(url, broadcast){
        cleanup();
        setStatus('Loadingâ€¦');

        
