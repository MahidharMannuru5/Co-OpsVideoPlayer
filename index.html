<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Watch Together â€” 50/50 + Fit/Fill + L/R Chat Bubbles (+ /yt)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <style>
        :root{
            --bg:#0c0d0f; --panel:#14171b; --border:#232834;
            --text:#e8eef3; --muted:#97a3ae; --accent:#00e1ff;
            --me:#00d4b3; --peer:#ff72d2;
            --safe-top: env(safe-area-inset-top, 0px);
            --safe-right: env(safe-area-inset-right, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
            --safe-left: env(safe-area-inset-left, 0px);

            /* ADDED: virtual keyboard support */
            --kbd: 0px;            /* current virtual keyboard height */
            --composer-h: 56px;    /* updated by JS after mount */
        }
        *{box-sizing:border-box}
        html,body{height:100%}
        body{
            margin:0; background:var(--bg); color:var(--text);
            font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
            line-height:1.4; overflow:hidden; /* no page scroll */
            padding:var(--safe-top) var(--safe-right) var(--safe-bottom) var(--safe-left);
            /* ADDED: avoid browser overscroll shifting the layout */
            overscroll-behavior:contain;
        }
        .hidden{display:none !important}

        /* Buttons/Inputs (compact) */
        .btn{
            display:inline-flex; align-items:center; justify-content:center;
            padding:10px 12px; border-radius:10px; border:1px solid var(--border);
            background:#0f1116; color:var(--text); font-weight:600; font-size:14px;
            cursor:pointer; line-height:1; white-space:nowrap;
        }
        .btn-primary{background:var(--accent); color:#001218; border-color:transparent}
        .btn-sm{padding:10px 12px; min-width:96px}
        input[type=text]{
            width:100%; padding:10px 12px; border-radius:10px; border:1px solid var(--border);
            background:#0f1116; color:#e8eef3; font-size:14px; line-height:1;
        }
        input::placeholder{color:var(--muted)}

        /* CONNECT (use 100dvh so mobile shows full UI) */
        .connectScreen{
            height:100dvh; width:100vw; display:flex; align-items:center; justify-content:center; padding:16px;
        }
        .connect{
            width:min(480px, 92vw);
            background:var(--panel); border:1px solid var(--border); border-radius:14px;
            padding:16px; display:flex; flex-direction:column; gap:10px;
        }
        .title{font-weight:800; color:var(--accent); text-align:center}
        .sub{color:var(--muted); font-size:13px; text-align:center}
        .row{display:flex; gap:8px; align-items:center}
        .row input{flex:1}

        /* SESSION: fullscreen split (100dvh for mobile browser chrome) */
        .session{
            height:100dvh; width:100vw; display:grid; gap:0;
            grid-template-columns: 1fr 1fr; grid-template-rows: 1fr; /* desktop: side-by-side */

            /* ADDED: keep layout fixed so video doesn't shift when keyboard opens */
            position:fixed; inset:0;
        }
        @media (max-width: 680px){
            .session{ grid-template-columns:1fr; grid-template-rows: 1fr 1fr; } /* mobile: top/bottom */
        }
        .left,.right{min-width:0; min-height:0}

        /* VIDEO (fills its half completely) */
        .left{position:relative; background:#000}
        .videoWrap{position:absolute; inset:0; background:#000; overflow:hidden}
        video{position:absolute; inset:0; width:100%; height:100%; background:#000}
        /* Fit/Fill modes toggled on .left */
        .left.mode-fill video { object-fit:cover; }   /* no gaps, can crop */
        .left.mode-fit  video { object-fit:contain; } /* no crop, may show bars */

        /* NEW: YouTube layer */
        #ytWrap{position:absolute; inset:0; display:none; background:#000}
        #ytPlayer{position:absolute; inset:0; width:100%; height:100%; border:0}

        /* Host vs guest interaction */
        .role-host video{pointer-events:auto}
        .role-guest video{pointer-events:none}

        /* badges + fit/fill toggle */
        .badges{
            position:absolute; top:8px; left:8px; display:flex; gap:6px; z-index:2;
            user-select:none; pointer-events:none;
        }
        .badge{
            background:rgba(0,0,0,.45); color:#eaf2f7; border:1px solid rgba(255,255,255,.12);
            padding:4px 8px; border-radius:999px; font-size:12px; backdrop-filter:saturate(120%) blur(6px);
        }
        .chip{
            pointer-events:auto; user-select:none; cursor:pointer;
            padding:4px 8px; border-radius:999px; font-size:12px; font-weight:700;
            border:1px solid rgba(255,255,255,.18);
            background:rgba(0,0,0,.55); color:#eaf2f7;
        }

        /* CHAT (right): vertical scroll only + left/right bubbles */
        .right{display:flex; flex-direction:column; background:var(--panel)}
        .chat{flex:1; display:flex; flex-direction:column; min-height:0; border-left:1px solid var(--border)}

        #messages{
            flex:1; min-height:0; overflow-y:auto; overflow-x:hidden; padding:12px; background:#0f1116;
            display:flex; flex-direction:column; gap:8px;
            word-break:break-word; overflow-wrap:anywhere; white-space:pre-wrap; /* wrap long lines; no horizontal scroll */
        }
        .line{display:flex; width:100%}
        .from-me{justify-content:flex-end}
        .from-peer{justify-content:flex-start}
        .from-sys{justify-content:center}

        .bubble{
            max-width:88%;
            padding:10px 12px;
            border-radius:14px;
            border:1px solid transparent;
            box-shadow:0 1px 2px rgba(0,0,0,.25);
            font-size:14px;
        }
        .bubble.me{
            background:rgba(0,212,179,.15); border-color:rgba(0,212,179,.35); color:#d9fff7;
            border-top-right-radius:6px;
        }
        .bubble.peer{
            background:rgba(255,114,210,.14); border-color:rgba(255,114,210,.35); color:#ffe6f6;
            border-top-left-radius:6px;
        }
        .bubble.sys{
            background:transparent; border-color:transparent; color:var(--muted);
            font-size:12px; padding:6px 8px; box-shadow:none;
        }

        .composer{
            display:flex; gap:8px; padding:8px; border-top:1px solid var(--border); background:var(--panel)
        }
        .composer input{flex:1}
        .composer button{
            padding:10px 12px; border-radius:10px; border:1px solid transparent;
            background:var(--accent); color:#001218; font-weight:700;
        }

        /* ====== ADDED (keyboard-aware chat without moving the video) ====== */
        /* Keep chat in a positioned context */
        .right .chat{ position:relative; }

        /* Make messages occupy space above the composer + keyboard */
        #messages{
            position:absolute; top:0; left:0; right:0;
            bottom: calc(var(--composer-h) + var(--kbd));
        }

        /* Lift composer exactly to the keyboard top (0 on desktop) */
        .composer{
            position:absolute; left:0; right:0; bottom: var(--kbd);
        }

        /* Optional: avoid smooth scroll jumps when keyboard toggles */
        .kbd-open #messages{ scroll-behavior:auto; }
        /* ====== /ADDED ====== */
            /* === Toasts & Error Bubbles === */
        .toasts{position:absolute; top:10px; right:10px; display:flex; flex-direction:column; gap:8px; z-index:5; width:min(360px, 90vw)}
        .toast{display:flex; gap:10px; align-items:flex-start; padding:10px 12px; border-radius:12px; border:1px solid var(--border); backdrop-filter:saturate(120%) blur(6px); box-shadow:0 2px 8px rgba(0,0,0,.35); background:rgba(0,0,0,.6); color:var(--text)}
        .toast .title{font-weight:800; color:inherit; text-align:left}
        .toast .msg{font-size:13px; color:var(--muted)}
        .toast button{margin-left:auto; border:none; background:transparent; color:inherit; cursor:pointer; font-weight:800}
        .toast.error{border-color:#ff6b6b; background:rgba(255,40,40,.12)}
        .toast.warn{border-color:#ffd166; background:rgba(255,209,102,.12)}
        .toast.info{border-color:#4da3ff; background:rgba(77,163,255,.12)}
        .bubble.err{background:rgba(255,40,40,.08); border-color:rgba(255,40,40,.4); color:#ffdfe0; box-shadow:0 2px 6px rgba(255,40,40,.12)}

    </style>

    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
</head>
<body>

<!-- Global toasts so errors are visible on BOTH screens -->
<div id="toasts" class="toasts" aria-live="polite"></div>

<section id="connectScreen" class="connectScreen">
    <div class="connect">
        <div class="title">ðŸŽ¬ Watch Together</div>
        <div class="sub">Desktop: Left video / Right chat (50/50). Mobile: Top/Bottom (50/50).</div>

        <button id="createBtn" class="btn btn-primary">Create Room (Host)</button>

        <div class="row">
            <input id="roomId" type="text" placeholder="Room ID" autofocus />
            <button id="joinBtn" class="btn btn-primary btn-sm">Join</button>
        </div>

                <div id="connectLog" class="sub"></div>
        <div id="connectErr" class="sub" style="color:#ffb4b4"></div>
    </div>
</section>

<section id="sessionScreen" class="session hidden">
    <div class="left mode-fill" id="leftPane">
        <div class="videoWrap">
            
            <div class="badges">
                <span id="roleBadge" class="badge">Not connected</span>
                <span id="statusBadge" class="badge">Idle</span>
                <button id="fitToggle" class="chip" title="Toggle Fit/Fill">Fill</button>
            </div>
            
            <video id="player" playsinline crossorigin="anonymous"></video>
            
            <!-- NEW: YouTube overlay container -->
            <div id="ytWrap"><div id="ytPlayer"></div></div>
            
            </div>
    </div>

    <div class="right">
        <div class="chat">
            <div id="messages"></div>
            <div class="composer">
                <input id="msgInput" type="text" placeholder="Messageâ€¦ (Host: /load, /yt, /vib)" />
                <button id="sendBtn" class="btn btn-primary btn-sm">Send</button>
            </div>
        </div>
    </div>
</section>

<script>
    // ===== Shortcuts =====
    const $ = id => document.getElementById(id);
    const connectScreen = $('connectScreen');
    const sessionScreen = $('sessionScreen');
    const roleBadge = $('roleBadge');
    const statusBadge = $('statusBadge');
    const player = $('player');
    const messages = $('messages');
    const leftPane = $('leftPane');
    const fitToggle = $('fitToggle');
    const ytWrap = $('ytWrap');
    const toasts = $('toasts');
    const connectErr = $('connectErr');

    // NOTE: Removed references to cameraConsent, enableCameraBtn, guestCameraFeed, localStream

    let peer, conn, isHost = false;
    let hls = null;
    let videoLoaded = false;
    let fitMode = null; 
    let permissionGranted = true; // No camera, so permission is trivially true

    // NEW: YouTube state
    let ytPlayer = null;
    let ytActive = false;
    let ytAPIReady = false;
    let ytSyncTimer = null;

    // ===== Fit/Fill Toggle (Existing Functionality) =====
    function setFitMode(mode){
        fitMode = mode;
        leftPane.classList.toggle('mode-fit',  mode==='fit');
        leftPane.classList.toggle('mode-fill', mode==='fill');
        fitToggle.textContent = mode === 'fit' ? 'Fit' : 'Fill';
        fitToggle.title = mode === 'fit' ? 'No crop (bars may appear)' : 'Fill (may crop)';
    }
    function pickDefaultMode(){
        const mobile = window.matchMedia('(max-width: 680px)').matches;
        setFitMode(mobile ? 'fit' : 'fill');
    }
    fitToggle.addEventListener('click', ()=> setFitMode(fitMode === 'fit' ? 'fill' : 'fit'));
    window.addEventListener('resize', ()=>{ if (fitMode==null) pickDefaultMode(); });

    // ===== UI helpers (MODIFIED log to be silent for system messages) =====
    function showConnect(msg){ $('connectLog').textContent = msg || ''; }
    function dbg(msg){
        const el = $('connectLog');
        el.textContent = (el.textContent ? el.textContent + '
' : '') + msg;
    }
    function toSession(role){
        connectScreen.classList.add('hidden');
        sessionScreen.classList.remove('hidden');
        sessionScreen.classList.toggle('role-host', role==='host');
        sessionScreen.classList.toggle('role-guest', role!=='host');
        roleBadge.textContent = role==='host' ? 'Host' : 'Guest';
        if (role==='host') player.setAttribute('controls',''); else player.removeAttribute('controls');
        // Removed camera consent setup for guest
        if (fitMode==null) pickDefaultMode();
    }

    // chat bubble helpers
    function addBubble(text, who){
        const line = document.createElement('div');
        line.className = 'line ' + (who==='me' ? 'from-me' : who==='peer' ? 'from-peer' : 'from-sys');
        const b = document.createElement('div');
        b.className = 'bubble ' + (who==='me' ? 'me' : who==='peer' ? 'peer' : 'sys');
        b.innerHTML = text;
        line.appendChild(b);
        messages.appendChild(line);
        messages.scrollTop = messages.scrollHeight;
    }
    
    // MODIFIED: Only show chat messages, suppress 'sys' messages
    function log(html, cls){
        if (cls === 'sys') {
            console.log("LOG: Suppressed system message: " + html.replace(/<[^>]*>?/gm, ''));
            return;
        }
        if (cls === 'err') {
            addBubble(html, 'sys');
            return;
        }
        addBubble(html, cls==='me' ? 'me' : 'peer');
    }
    function setStatus(text){ statusBadge.textContent = text; }
    function escapeHtml(s){ return s.replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':m==='"'?'&quot;':'&#39;' }[m])) }

    // ===== Error/Toast helpers =====
    function pushToast(type, title, msg){
        const t = document.createElement('div'); t.className = `toast ${type}`;
        t.innerHTML = `<div class=\"title\">${escapeHtml(title)}</div><div class=\"msg\">${escapeHtml(msg||'')}</div>`;
        const close = document.createElement('button'); close.setAttribute('aria-label','Dismiss'); close.textContent='âœ•';
        close.onclick = ()=> t.remove();
        t.appendChild(close);
        toasts.appendChild(t);
        setTimeout(()=>{ t.remove(); }, 6000);
    }
    function showError(title, msg){
        pushToast('error', title, msg||'');
        log(`<b>${escapeHtml(title)}:</b> ${escapeHtml(msg||'')}`, 'err');
    }
    function showInfo(title, msg){ pushToast('info', title, msg||''); }

    function setStatus(text){ statusBadge.textContent = text; }
    function escapeHtml(s){ return s.replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':m==='"'?'&quot;':'&#39;' }[m])) }

    // ===== Connect flow (Existing Functionality - MODIFIED to be silent) =====
    $('createBtn').onclick = () => {
        // Immediate visibility
        if (!navigator.onLine){ showError('You are offline','Connect to the internet and try again.'); return; }
        if (!window.Peer){ showError('PeerJS missing','The PeerJS script failed to load. Check ad-blockers/CDN.'); return; }
        try{
            connectErr.textContent = '';
            showConnect('Creating roomâ€¦');
            dbg('Creating Peerâ€¦');
            isHost = true;
            peer = new Peer();

            // Watchdog: in case open never fires
            const watchdog = setTimeout(()=>{
                showError('Peer server unreachable','Could not establish a connection to the Peer server.');
                connectErr.textContent = 'Peer server unreachable. Check network or try again.';
            }, 8000);

            peer.on('open', id => {
                clearTimeout(watchdog);
                showConnect(`Room ID: ${id}`);
                dbg('Peer open âœ“');
                console.log(`DEBUG: Room created. ID: ${id}`);
            });
            peer.on('error', err => {
                clearTimeout(watchdog);
                console.error('Peer error (host):', err);
                connectErr.textContent = err?.message || String(err);
                showError('Peer error', err?.message || String(err));
            });
            peer.on('connection', c => {
                conn = c; wireConnection(); toSession('host');
                console.log('DEBUG: Peer connection established (Host)'); 
            });
            peer.on('disconnected', ()=> showError('Disconnected', 'The peer server connection dropped.'));
        }catch(e){
            showError('Create room failed', e?.message || String(e));
        }
    };

    $('joinBtn').onclick = tryJoin;
    $('roomId').addEventListener('keydown', e => { if (e.key === 'Enter') tryJoin(); });

    function tryJoin(){
        const id = $('roomId').value.trim();
        if (!id) { showConnect('Enter a room ID.'); connectErr.textContent = 'Room ID is required to join.'; $('roomId').focus(); showError('Missing Room ID','Please enter a Room ID and try again.'); return; }
        if (!navigator.onLine){ showError('You are offline','Connect to the internet and try again.'); return; }
        if (!window.Peer){ showError('PeerJS missing','The PeerJS script failed to load. Check ad-blockers/CDN.'); return; }
        isHost = false;
        try{
            connectErr.textContent = '';
            showConnect('Joining roomâ€¦');
            peer = new Peer();

            const watchdog = setTimeout(()=>{
                showError('Peer server unreachable','Could not connect to the Peer server.');
                connectErr.textContent = 'Peer server unreachable. Check network or try again.';
            }, 8000);

            peer.on('open', () => {
                clearTimeout(watchdog);
                conn = peer.connect(id);
                conn.on('open', () => {
                    wireConnection(); toSession('guest');
                    console.log(`DEBUG: Joined room successfully (Guest)`); 
                });
                conn.on('error', err => { showError('Connection error', err?.message || String(err)); });
                conn.on('close', () => { showError('Connection closed','Peer disconnected. Reloadingâ€¦'); setTimeout(()=>location.reload(), 1200); });
            });
            peer.on('error', err => { clearTimeout(watchdog); showError('Peer error', err?.message || String(err)); connectErr.textContent = err?.message || String(err); });
        }catch(e){
            showError('Join failed', e?.message || String(e));
        }
    }
        isHost = false;
        try{
            peer = new Peer();
            peer.on('open', () => {
                conn = peer.connect(id);
                conn.on('open', () => {
                    wireConnection(); toSession('guest');
                    console.log(`DEBUG: Joined room successfully (Guest)`); 
                });
                conn.on('error', err => { showError('Connection error', err?.message || String(err)); });
                conn.on('close', () => { showError('Connection closed','Peer disconnected. Reloadingâ€¦'); setTimeout(()=>location.reload(), 1200); });
            });
            peer.on('error', err => { showError('Peer error', err?.message || String(err)); });
        }catch(e){
            showError('Join failed', e?.message || String(e));
        }
    }
        isHost = false;
        peer = new Peer();
        peer.on('open', () => {
            conn = peer.connect(id);
            conn.on('open', () => {
                wireConnection(); toSession('guest');
                console.log(`DEBUG: Joined room successfully (Guest)`); 
            });
        });
    }

    // ===== VIBRATION API Function (Used by /vib) =====
    function applyVibration(pattern) {
        if (typeof navigator.vibrate === 'function') {
            console.log(`DEBUG: Triggering vibration pattern: ${pattern}`);
            try{ navigator.vibrate(pattern); }catch(e){ showError('Vibration failed', e?.message || String(e)); }
        } else {
            showError('Vibration unsupported','This device/browser does not support the Vibration API.');
            console.warn('Vibration API not supported on this device/browser.');
        }
    }`);
            navigator.vibrate(pattern);
        } else {
            console.warn('Vibration API not supported on this device/browser.');
        }
    }
    // Removed captureCameraFrame, forceDownload functions
    

    // ===== wireConnection (UPDATED for /yt + VIB) =====
    function wireConnection(){
        conn.on('data', data => {
            try{
                if (data.type === 'chat'){
                    log(`<b>Peer:</b> ${escapeHtml(data.text)}`, 'peer');
                } else if (data.type === 'cmd' && data.cmd === 'load'){
                    loadMedia(data.url, false);
                } else if (data.type === 'cmd' && data.cmd === 'yt'){
                    loadYouTubeById(data.videoId, false);
                } else if (data.type === 'sync'){
                    applySync(data);
                } 
                else if (data.type === 'vibrate'){
                    applyVibration(data.pattern);
                }
            }catch(e){ showError('Incoming data error', e?.message || String(e)); }
        });
        conn.on('close', () => {
            showError('Connection closed','Peer connection was closed. Reloadingâ€¦');
            console.warn('CONNECTION CLOSED: Peer connection was closed. Reloading page.');
            setTimeout(()=> location.reload(), 1200);
        });
        conn.on('error', err => showError('Connection error', err?.message || String(err)));
    }`, 'peer');
            } else if (data.type === 'cmd' && data.cmd === 'load'){
                loadMedia(data.url, false);
            } else if (data.type === 'cmd' && data.cmd === 'yt'){
                loadYouTubeById(data.videoId, false);
            } else if (data.type === 'sync'){
                applySync(data);
            } 
            // --- Handle incoming vibration command (SILENT) ---
            else if (data.type === 'vibrate'){
                applyVibration(data.pattern);
            }
            // Removed /snap command handler
            // Removed snap_data handler
        });
        conn.on('close', () => {
            console.warn('CONNECTION CLOSED: Peer connection was closed. Reloading page.');
            location.reload();
        });
    }

    // ===== Chat (MODIFIED: /load, /yt, /vib) =====
    $('sendBtn').onclick = sendMsg;
    $('msgInput').addEventListener('keydown', e => { if (e.key === 'Enter') sendMsg(); });
    
    const secToMs = (val) => Math.round(parseFloat(val) * 1000);

    function sendMsg(){
        const el = $('msgInput'), text = el.value.trim();
        if (!text) return;
        if (!conn || (conn.open===false)) { showError('Not connected','Create or join a room before sending messages.'); return; }
        
        // --- COMMAND HANDLING (HOST ONLY) ---
        if (isHost) {
            if (text.startsWith('/load ')) {
                const url = text.slice(6).trim();
                if (!url){ showError('Missing URL','/load requires a media URL.'); el.value=''; return; }
                try{ loadMedia(url, true); }catch(e){ showError('Load failed', e?.message || String(e)); }
                el.value = ''; 
                console.log(`DEBUG: Host command: /load ${url}`); 
                return;
            } else if (text.startsWith('/yt ')) {
                const url = text.slice(4).trim();
                const vid = extractYouTubeId(url);
                if (!vid) { showError('Invalid YouTube URL','Could not extract a video ID.'); el.value=''; return; }
                loadYouTubeById(vid, true).catch(e=> showError('YouTube load failed', e?.message || String(e)));
                el.value = '';
                console.log(`DEBUG: Host command: /yt ${vid}`);
                return;
            } else if (text.startsWith('/vib ')) {
                const payload = text.slice(5).trim();
                if (!payload) { showError('Vibration payload missing','Provide seconds or a comma pattern.'); el.value = ''; return; }
                
                let pattern;
                if (payload.includes(',')) {
                    const parts = payload.split(',');
                    pattern = parts.map(sec => secToMs(sec));
                } else {
                    pattern = secToMs(payload);
                }
                
                if (pattern === 0 || (Array.isArray(pattern) && pattern.some(isNaN))) {
                    showError('Invalid vibration pattern','Use numbers in seconds, e.g., "/vib 0.1,0.1,0.2"'); el.value = ''; return;
                }

                try{ applyVibration(pattern); conn?.send({type:'vibrate', pattern}); }catch(e){ showError('Vibration failed', e?.message || String(e)); }
                el.value = ''; 
                console.log(`DEBUG: Host command: /vib ${payload} (Sent as ${pattern})`);
                return;
            } 
        }
        
        // --- REGULAR CHAT MESSAGE ---
        try{
            log(`<b>You:</b> ${escapeHtml(text)}`, 'me');
            conn?.send({type:'chat', text});
        }catch(e){ showError('Send failed', e?.message || String(e)); }
        el.value = '';
    }`); 
                return;
            } else if (text.startsWith('/yt ')) {
                const url = text.slice(4).trim();
                const vid = extractYouTubeId(url);
                if (!vid) { console.error('YT: Invalid YouTube URL'); el.value=''; return; }
                loadYouTubeById(vid, true);
                el.value = '';
                console.log(`DEBUG: Host command: /yt ${vid}`);
                return;
            } else if (text.startsWith('/vib ')) {
                const payload = text.slice(5).trim();
                if (!payload) { console.error('VIB: Missing payload'); el.value = ''; return; }
                
                let pattern;
                if (payload.includes(',')) {
                    const parts = payload.split(',');
                    pattern = parts.map(sec => secToMs(sec));
                } else {
                    pattern = secToMs(payload);
                }
                
                if (pattern === 0 || (Array.isArray(pattern) && pattern.some(isNaN))) {
                    console.error('VIB: Invalid duration or pattern.'); el.value = ''; return;
                }

                applyVibration(pattern);
                conn?.send({type:'vibrate', pattern});
                el.value = ''; 
                console.log(`DEBUG: Host command: /vib ${payload} (Sent as ${pattern})`);
                return;
            } 
            // Removed /snap command logic
        }
        
        // --- REGULAR CHAT MESSAGE ---
        log(`<b>You:</b> ${escapeHtml(text)}`, 'me');
        conn?.send({type:'chat', text});
        el.value = '';
    }

    // ===== Media loading (HTML5 + HLS) (Existing Functionality) =====
    function cleanup(){
        // stop YT if active
        if (ytActive) destroyYouTube();
        if (hls){ try{ hls.destroy(); }catch(e){} hls = null; }
        player.pause(); player.removeAttribute('src'); player.load();
        videoLoaded = false;
    }

    function loadMedia(url, broadcast){
        cleanup();
        setStatus('Loadingâ€¦'); 

        if (url.toLowerCase().includes('.m3u8')){
            if (window.Hls && Hls.isSupported()){
                try{
                    hls = new Hls({ backBufferLength: 600, liveSyncDuration: 6, liveMaxLatencyDuration: 300 });
                    hls.on(Hls.Events.ERROR, (_, data)=> { console.warn('hls.js error', data); showError('HLS error', (data && (data.details||data.type)) || 'Unknown HLS error'); });
                    hls.loadSource(url);
                    hls.attachMedia(player);
                    hls.on(Hls.Events.MANIFEST_PARSED, ()=>{ videoLoaded = true; setStatus('Ready'); if (!isHost) player.currentTime = 0; });
                }catch(e){ showError('HLS setup failed', e?.message || String(e)); return; }
            } else if (player.canPlayType('application/vnd.apple.mpegurl')){
                player.src = url; player.onloadedmetadata = ()=>{ videoLoaded = true; setStatus('Ready'); };
            } else {
                setStatus('HLS unsupported in this browser'); 
                showError('HLS unsupported','This browser cannot play HLS (.m3u8) streams.');
                console.error('DEBUG: HLS unsupported in browser.');
                return;
            }
        } else {
            player.src = url; 
            player.onloadedmetadata = ()=>{ 
                videoLoaded = true; 
                setStatus('Ready');
            };
        }

        player.onerror = () => {
            const err = player.error; const msg = err ? (err.message || `Media error code ${err.code}`) : 'Unknown video error';
            showError('Video playback error', msg);
        };

        if (broadcast){
            try{ conn?.send({type:'cmd', cmd:'load', url}); }catch(e){ showError('Broadcast failed', e?.message || String(e)); }
        }
    });
                hls.on(Hls.Events.ERROR, (_, data)=> console.warn('hls.js error', data));
                hls.loadSource(url);
                hls.attachMedia(player);
                hls.on(Hls.Events.MANIFEST_PARSED, ()=>{ videoLoaded = true; setStatus('Ready'); if (!isHost) player.currentTime = 0; });
            } else if (player.canPlayType('application/vnd.apple.mpegurl')){
                player.src = url; player.onloadedmetadata = ()=>{ videoLoaded = true; setStatus('Ready'); };
            } else {
                setStatus('HLS unsupported in this browser'); 
                console.error('DEBUG: HLS unsupported in browser.');
                return;
            }
        } else {
            player.src = url; 
            player.onloadedmetadata = ()=>{ 
                videoLoaded = true; 
                setStatus('Ready');
            };
        }

        if (broadcast){
            conn?.send({type:'cmd', cmd:'load', url});
        }
    }

    // ===== Sync host -> guest (Existing Functionality) =====
    player.addEventListener('play', () => {
        if (!isHost || !videoLoaded || ytActive) return;
        conn?.send({type:'sync', action:'play', time:player.currentTime, media:'html5'});
    });
    player.addEventListener('pause', () => {
        if (!isHost || !videoLoaded || ytActive) return;
        conn?.send({type:'sync', action:'pause', time:player.currentTime, media:'html5'});
    });
    let seekTimer;
    player.addEventListener('seeked', () => {
        if (!isHost || !videoLoaded || ytActive) return;
        clearTimeout(seekTimer);
        seekTimer = setTimeout(()=> {
            conn?.send({type:'sync', action:'seek', time:player.currentTime, media:'html5'});
        }, 80);
    });

    function applySync(msg){
        // Route based on active media
        if (ytActive && ytPlayer){
            const t = msg.time ?? 0;
            const diff = Math.abs((ytPlayer.getCurrentTime ? ytPlayer.getCurrentTime() : 0) - t);
            if (msg.action === 'play') {
                if (diff > 0.4) ytPlayer.seekTo(t, true);
                ytPlayer.playVideo && ytPlayer.playVideo();
            } else if (msg.action === 'pause') {
                if (diff > 0.4) ytPlayer.seekTo(t, true);
                ytPlayer.pauseVideo && ytPlayer.pauseVideo();
            } else if (msg.action === 'seek' || msg.action === 'time') {
                if (diff > 0.4) ytPlayer.seekTo(t, true);
            }
            return;
        }
        // HTML5 video path
        if (!videoLoaded) return;
        const diff = Math.abs(player.currentTime - msg.time);
        if (diff > 0.4) player.currentTime = msg.time;
        if (msg.action === 'play')  player.play().catch(()=>{});
        if (msg.action === 'pause') player.pause();
    }

    /* ===== ADDED: keyboard-aware chat (Existing Functionality) ===== */
    (function setupKeyboardAwareChat(){
        const vv = window.visualViewport;
        const composer = document.querySelector('.composer');
        function setVar(name, val){ document.documentElement.style.setProperty(name, val); }
        function measureComposer(){
            if (composer) setVar('--composer-h', composer.offsetHeight + 'px');
        }
        function updateKeyboardOffset(){
            const kb = vv ? Math.max(0, (window.innerHeight - vv.height - vv.offsetTop)) : 0;
            const isOpen = kb > 120; // threshold to ignore tiny resizes
            setVar('--kbd', (isOpen ? kb : 0) + 'px');
            document.body.classList.toggle('kbd-open', isOpen);
            measureComposer();
        }
        window.addEventListener('load', updateKeyboardOffset, { once:true });
        window.addEventListener('resize', updateKeyboardOffset);
        window.addEventListener('orientationchange', updateKeyboardOffset);
        if (vv){
            vv.addEventListener('resize', updateKeyboardOffset);
            vv.addEventListener('scroll', updateKeyboardOffset);
        }
        const msgInput = document.getElementById('msgInput');
        if (msgInput){
            msgInput.addEventListener('focus', () => { setTimeout(updateKeyboardOffset, 0); });
            msgInput.addEventListener('blur',  () => { setTimeout(updateKeyboardOffset, 0); });
        }
    })();
    /* ===== /ADDED ===== */

    // ======== NEW: YouTube helpers (/yt) ========
    function injectYouTubeAPI(){
        return new Promise((resolve, reject) => {
            if (ytAPIReady) return resolve();
            if (window.YT && window.YT.Player){ ytAPIReady = true; return resolve(); }
            const tag = document.createElement('script');
            tag.src = 'https://www.youtube.com/iframe_api';
            tag.onerror = () => { showError('YouTube API load failed','Check your network connection.'); reject(new Error('YT API load failed')); };
            document.head.appendChild(tag);
            window.onYouTubeIframeAPIReady = () => { ytAPIReady = true; resolve(); };
        });
    }
            const tag = document.createElement('script');
            tag.src = 'https://www.youtube.com/iframe_api';
            document.head.appendChild(tag);
            window.onYouTubeIframeAPIReady = () => { ytAPIReady = true; resolve(); };
        });
    }

    function extractYouTubeId(url){
        try{
            // Support youtu.be/ID and youtube.com/watch?v=ID and shorts
            const u = new URL(url);
            if (u.hostname.includes('youtu.be')) return u.pathname.slice(1);
            if (u.searchParams.get('v')) return u.searchParams.get('v');
            const path = u.pathname.split('/').filter(Boolean);
            const idx = path.indexOf('shorts');
            if (idx !== -1 && path[idx+1]) return path[idx+1];
            // embed URL
            const eidx = path.indexOf('embed');
            if (eidx !== -1 && path[eidx+1]) return path[eidx+1];
            return null;
        }catch(e){ return null; }
    }

    async function loadYouTubeById(videoId, broadcast){
        cleanup(); // ensure HTML5 player is stopped
        setStatus('Loadingâ€¦');
        await injectYouTubeAPI();
        ytWrap.style.display = 'block';
        player.style.display = 'none';
        ytActive = true;
        ytPlayer = new YT.Player('ytPlayer', {
            videoId,
            playerVars: {
                rel: 0,
                modestbranding: 1,
                playsinline: 1,
                fs: 1,
                controls: isHost ? 1 : 0,
                disablekb: isHost ? 0 : 1
            },
            events: {
                onReady: (ev) => {
                    videoLoaded = true; setStatus('Ready');
                },
                onStateChange: (ev) => {
                    if (!isHost || !videoLoaded) return;
                    const t = ytPlayer.getCurrentTime ? ytPlayer.getCurrentTime() : 0;
                    if (ev.data === YT.PlayerState.PLAYING){
                        conn?.send({type:'sync', action:'play', time:t, media:'yt'});
                        startYTSyncTicker();
                    } else if (ev.data === YT.PlayerState.PAUSED){
                        conn?.send({type:'sync', action:'pause', time:t, media:'yt'});
                        stopYTSyncTicker();
                    } else if (ev.data === YT.PlayerState.BUFFERING){
                        conn?.send({type:'sync', action:'seek', time:t, media:'yt'});
                    } else if (ev.data === YT.PlayerState.ENDED){
                        stopYTSyncTicker();
                    }
                },
                onError: (ev) => {
                    const codes = {2:'Invalid parameter',5:'HTML5 playback issue',100:'Video not found/private',101:'Embedding disabled',150:'Embedding disabled'};
                    showError('YouTube error', codes[ev?.data] || `Player error code ${ev?.data}`);
                }
            }
        });
        if (broadcast){
            try{ conn?.send({type:'cmd', cmd:'yt', videoId}); }catch(e){ showError('Broadcast failed', e?.message || String(e)); }
        }
    },
            events: {
                onReady: (ev) => {
                    videoLoaded = true; setStatus('Ready');
                },
                onStateChange: (ev) => {
                    if (!isHost || !videoLoaded) return;
                    const t = ytPlayer.getCurrentTime ? ytPlayer.getCurrentTime() : 0;
                    if (ev.data === YT.PlayerState.PLAYING){
                        conn?.send({type:'sync', action:'play', time:t, media:'yt'});
                        startYTSyncTicker();
                    } else if (ev.data === YT.PlayerState.PAUSED){
                        conn?.send({type:'sync', action:'pause', time:t, media:'yt'});
                        stopYTSyncTicker();
                    } else if (ev.data === YT.PlayerState.BUFFERING){
                        // treat as a seek hint
                        conn?.send({type:'sync', action:'seek', time:t, media:'yt'});
                    } else if (ev.data === YT.PlayerState.ENDED){
                        stopYTSyncTicker();
                    }
                }
            }
        });
        if (broadcast){
            conn?.send({type:'cmd', cmd:'yt', videoId});
        }
    }

    function destroyYouTube(){
        stopYTSyncTicker();
        try{ ytPlayer && ytPlayer.destroy && ytPlayer.destroy(); }catch(e){}
        ytPlayer = null;
        ytActive = false;
        ytWrap.style.display = 'none';
        player.style.display = 'block';
    }

    function startYTSyncTicker(){
        stopYTSyncTicker();
        ytSyncTimer = setInterval(()=>{
            if (!isHost || !ytPlayer) return;
            const t = ytPlayer.getCurrentTime ? ytPlayer.getCurrentTime() : 0;
            conn?.send({type:'sync', action:'time', time:t, media:'yt'});
        }, 2000);
    }
    function stopYTSyncTicker(){
        if (ytSyncTimer){ clearInterval(ytSyncTimer); ytSyncTimer = null; }
    }
    // ======== /YouTube helpers ========

    // Init default fit/fill on load (Existing Functionality)
    window.addEventListener('load', pickDefaultMode);

    // Global error catches so we always see problems
    window.addEventListener('error', (e) => {
        showError('Script error', e?.message || 'Unknown script error');
    });
    window.addEventListener('unhandledrejection', (e) => {
        const msg = (e && e.reason && (e.reason.message || String(e.reason))) || 'Unhandled promise rejection';
        showError('Unhandled error', msg);
    });

    // Detect missing PeerJS after load (CDN blocked?)
    window.addEventListener('load', () => {
        setTimeout(() => {
            if (!window.Peer){ showError('PeerJS not loaded','The PeerJS CDN may be blocked. Try a different network or allow the script.'); }
        }, 1500);
    });

    // Show online/offline state to the user
    window.addEventListener('offline', () => showError('You went offline','Reconnect to continue.'));
    window.addEventListener('online', () => showInfo('Back online','You can create or join rooms again.'));

    // Global error catches so we always see problems
    window.addEventListener('error', (e) => {
        showError('Script error', e?.message || 'Unknown script error');
    });
    window.addEventListener('unhandledrejection', (e) => {
        const msg = (e && e.reason && (e.reason.message || String(e.reason))) || 'Unhandled promise rejection';
        showError('Unhandled error', msg);
    });
</script>
</body>
</html>
